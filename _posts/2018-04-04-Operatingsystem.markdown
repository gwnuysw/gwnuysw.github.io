---
layout: post
title:  "운영체제 프로세스와 스레드의 생성 및 제거"
date:   2018-04-04 22:08:00 +0900
categories: jekyll update
---
### 프로세스 생성

- 터미널
```
$ sample (enter)
```
- 쉘 프로세스
```
while(1)
{
  read(0,buf, 80);
  pid = fork(); // os에 fork서비스를 요구하면 os는 또 다른 쉘에서 자식 프로세스를 생성해 준다.
  if(pid > 0) // 부모 프로세스는 0이 아니기 때문에
    wait(&st, 0); //자식 프로세스가 끝날때까지 기다린다. 하지만 wait줄 까지 오기 전에 자식 프로세스가 종료 될 수 있는데 그것을 그러면 자식 프로세스는 운영체제가 폐기 시켜주길 기다린다. 그러한 프로세스 상태를 Zombie상태라고 한다.
  else
    execl(buf, NULL);
}
```

- 또 다른 쉘에서 생성된 복제 프로세스
```
while(1)
{
  read(0,buf, 80);
  pid = fork();
  if(pid > 0)
    wait(&st, 0);
  else  // 자식 프로세스는 pid가 0이기 때문에
    execl(buf, NULL); //쉘 할당 받은 메모리 공간을 실행 프로그램으로 대치 시킨다.
}
```
- 메모리에 대체된 sample 프로그램
```
main()
{
  printf("I am sample. \n");

  exit(0);//해당 프로세스를 제거하고 그 결과를 wait에서 대기중인 부모 프로세스에게 알린다.
}
```
---
### 프로세스간 통신(Inter-Process Communication : IPC)

프로그램의 규모가 크거나 복잡하면 개발 효율성 및 처리 성능 향상을 위해 여러개의 작은 프로그램으로 분리 되어야 한다. 가장 일반적인 통신 수단으로 인터넷(TCP/IP)과 파이프(Pipe)가 있다. 인터넷은 멀리 떨어져 있는 원격 시스템 통신뿐만 아니라 동일 시스템의 프로세스들도 가능하다.

---

### 프로세스 통제

프로그램 작성 오류에 의한 무한 루프 프로세스를 만났을때 사용자는 그 프로세스를 종료시킬 수 있어야 한다. 그 예로 유닉스 리눅스 운영체제에서는 kill()시스템 콜이 있고 kill 명령어가 있다.

---
### 프로세서(CPU) 관리

프로세스 time sharing은 단순히 jump 명령어로 실행된다. 그때 time interrupt를 이용해서 jump를 한다.
